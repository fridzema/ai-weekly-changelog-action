# action.yml
name: 'Weekly Changelog via OpenRouter'
description: 'Generates a weekly changelog from git commits using an AI model via OpenRouter and commits it to the repository.'
author: 'fridzema'

branding:
  icon: 'git-pull-request'
  color: 'purple'

inputs:
  openrouter_api_key:
    description: 'API key for OpenRouter.ai'
    required: true
  github_token:
    description: '[DEPRECATED - Not needed] GitHub token is automatically provided by GitHub Actions context.'
    required: false
    default: ${{ github.token }}
  days_back:
    description: 'Number of days to look back for commits (1-365). Ignored if from_ref is provided.'
    required: false
    default: '7'
  from_ref:
    description: 'Git ref to start from (tag, commit, branch). If provided, days_back is ignored.'
    required: false
    default: ''
  to_ref:
    description: 'Git ref to end at (tag, commit, branch). Defaults to HEAD.'
    required: false
    default: 'HEAD'
  model:
    description: 'The OpenRouter model to use (e.g., openai/gpt-5-mini).'
    required: false
    default: 'openai/gpt-5-mini'
  language:
    description: 'Output language for the changelog.'
    required: false
    default: 'English'
  force:
    description: 'Force update even if a changelog entry for the current week already exists.'
    required: false
    default: 'false'
  extended:
    description: 'Enable extended analysis with file changes and deeper commit inspection.'
    required: false
    default: 'false'
  dry_run:
    description: 'Generate changelog without committing (outputs to step summary instead).'
    required: false
    default: 'false'

runs:
  using: "composite"
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        FROM_REF="${{ inputs.from_ref }}"
        DAYS_BACK="${{ inputs.days_back }}"

        # Only validate days_back if from_ref is not provided
        if [ -z "$FROM_REF" ]; then
          if ! [[ "$DAYS_BACK" =~ ^[0-9]+$ ]] || [ "$DAYS_BACK" -gt 365 ] || [ "$DAYS_BACK" -lt 1 ]; then
            echo "‚ùå Invalid days_back value: $DAYS_BACK. Must be a number between 1-365."
            exit 1
          fi
          echo "‚úÖ Input validation passed (using days_back: $DAYS_BACK)"
        else
          echo "‚úÖ Input validation passed (using ref range: $FROM_REF...${{ inputs.to_ref }})"
        fi

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        # Use full history when using refs (needed to find tags/commits), otherwise dynamic depth
        fetch-depth: ${{ inputs.from_ref != '' && 0 || (inputs.days_back <= 7 && 100 || (inputs.days_back <= 30 && 300 || 500)) }}

    - name: Collect commits and file changes
      id: commits
      shell: bash
      run: |
        # Consolidated git operations for optimal performance
        FROM_REF="${{ inputs.from_ref }}"
        TO_REF="${{ inputs.to_ref }}"
        DAYS_BACK="${{ inputs.days_back }}"
        EXTENDED="${{ inputs.extended }}"

        # Common git filter patterns (simplified to avoid escaping issues)
        GIT_FILTERS="--no-merges"

        # Determine commit range mode: ref-based or date-based
        if [ -n "$FROM_REF" ]; then
          # Ref-based mode: use from_ref..to_ref range
          USE_REF_MODE="true"
          COMMIT_RANGE="${FROM_REF}..${TO_REF}"
          echo "üìç Using ref-based commit range: $COMMIT_RANGE"
          echo "üîß Debug: Using filters: $GIT_FILTERS"

          # Validate refs exist
          if ! git rev-parse "$FROM_REF" >/dev/null 2>&1; then
            echo "‚ùå Error: from_ref '$FROM_REF' does not exist"
            exit 1
          fi
          if ! git rev-parse "$TO_REF" >/dev/null 2>&1; then
            echo "‚ùå Error: to_ref '$TO_REF' does not exist"
            exit 1
          fi

          # Quick test to see if any commits exist at all
          TOTAL_COMMITS=$(git log "$COMMIT_RANGE" --oneline 2>/dev/null | wc -l || echo "0")
          FILTERED_COMMITS=$(git log "$COMMIT_RANGE" $GIT_FILTERS --oneline 2>/dev/null | wc -l || echo "0")
          echo "üìä Debug: Total commits in range: $TOTAL_COMMITS, After filters: $FILTERED_COMMITS"
        else
          # Date-based mode: use --since with days_back
          USE_REF_MODE="false"
          SINCE_DATE=$(date -d "${DAYS_BACK} days ago" -u +"%Y-%m-%dT%H:%M:%SZ")
          COMMIT_RANGE=""
          echo "üìÖ Using date-based collection: commits since $SINCE_DATE"
          echo "üîß Debug: Using filters: $GIT_FILTERS"

          # Quick test to see if any commits exist at all
          TOTAL_COMMITS=$(git log --since="$SINCE_DATE" --oneline | wc -l || echo "0")
          FILTERED_COMMITS=$(git log --since="$SINCE_DATE" $GIT_FILTERS --oneline | wc -l || echo "0")
          echo "üìä Debug: Total commits in period: $TOTAL_COMMITS, After filters: $FILTERED_COMMITS"
        fi

        # Create cache key based on repository state and parameters
        LATEST_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
        if [ "$USE_REF_MODE" = "true" ]; then
          CACHE_KEY="${LATEST_COMMIT:0:8}_${FROM_REF}_${TO_REF}_${EXTENDED}"
        else
          CACHE_KEY="${LATEST_COMMIT:0:8}_${DAYS_BACK}_${EXTENDED}"
        fi
        CACHE_DIR="/tmp/changelog_cache"
        CACHE_FILE="$CACHE_DIR/$CACHE_KEY"
        
        mkdir -p "$CACHE_DIR"
        
        # Check cache first
        if [[ -f "$CACHE_FILE" && -f "${CACHE_FILE}.meta" ]]; then
          echo "üì¶ Using cached results for key: $CACHE_KEY"
          source "${CACHE_FILE}.meta"
          if [[ -f "${CACHE_FILE}_commits.txt" ]]; then
            cp "${CACHE_FILE}_commits.txt" commits.txt
            if [[ "$EXTENDED" == "true" && -f "${CACHE_FILE}_extended.txt" ]]; then
              cp "${CACHE_FILE}_extended.txt" commits_extended.txt
              [[ -f "${CACHE_FILE}_files.txt" ]] && cp "${CACHE_FILE}_files.txt" files_changed.txt
            fi
            echo "‚úÖ Cache hit - skipping git operations"
          else
            echo "‚ö†Ô∏è Cache miss - incomplete cache data"
            rm -f "$CACHE_FILE"*
          fi
        fi
        
        # If no cache hit, perform git operations
        if [[ ! -f commits.txt ]]; then
          echo "üîç Performing git analysis..."
          
          if [[ "$EXTENDED" == "true" ]]; then
            echo "üìä Extended analysis enabled - collecting comprehensive data in parallel..."

            # Run independent git operations in parallel for better performance
            echo "üîç Collecting commits and extended data..."

            # Determine git log arguments based on mode
            if [ "$USE_REF_MODE" = "true" ]; then
              GIT_LOG_RANGE="$COMMIT_RANGE"
            else
              GIT_LOG_RANGE="--since=$SINCE_DATE"
            fi

            # Basic commits (background)
            (
              if ! git log $GIT_LOG_RANGE $GIT_FILTERS \
                --pretty=format:'%H|%s|%an|%ad|%h' --date=short > commits.txt; then
                echo "‚ö†Ô∏è  Advanced filters failed, using basic collection"
                git log $GIT_LOG_RANGE --no-merges \
                  --pretty=format:'%H|%s|%an|%ad|%h' --date=short > commits.txt || true
              fi
            ) &
            PID1=$!

            # Extended commit info (background)
            git log $GIT_LOG_RANGE $GIT_FILTERS \
              --name-status --pretty=format:'COMMIT:%H|%s|%an|%ad|%h' > commits_extended.txt &
            PID2=$!

            # Wait for both operations to complete
            wait $PID1 $PID2

            # Check if we got commits before proceeding with statistics
            if [[ -s commits.txt ]]; then
              echo "‚úÖ Found commits, collecting statistics..."

              # Collect statistics (sequential - depends on previous data)
              git log $GIT_LOG_RANGE $GIT_FILTERS \
                --numstat --name-only --pretty=format: | \
                awk '/^[0-9]/ {add+=$1; del+=$2} /^[^0-9]/ && NF {files[$0]=1} END {for(f in files) print f > "files_changed.txt"; print add+0 > "lines_added.tmp"; print del+0 > "lines_deleted.tmp"}' || true
            else
              echo "‚ÑπÔ∏è No commits found, skipping extended analysis"
            fi
            
            LINES_ADDED=$(cat lines_added.tmp 2>/dev/null || echo "0")
            LINES_DELETED=$(cat lines_deleted.tmp 2>/dev/null || echo "0")
            FILES_CHANGED=$(wc -l < files_changed.txt 2>/dev/null || echo "0")
            
            echo "lines_added=$LINES_ADDED" >> "$GITHUB_OUTPUT"
            echo "lines_deleted=$LINES_DELETED" >> "$GITHUB_OUTPUT"
            echo "files_changed=$FILES_CHANGED" >> "$GITHUB_OUTPUT"
            echo "extended_analysis=true" >> "$GITHUB_OUTPUT"
            
            # Cache results
            cp commits.txt "${CACHE_FILE}_commits.txt"
            cp commits_extended.txt "${CACHE_FILE}_extended.txt" 2>/dev/null || true
            cp files_changed.txt "${CACHE_FILE}_files.txt" 2>/dev/null || true
            echo "lines_added=$LINES_ADDED" > "${CACHE_FILE}.meta"
            echo "lines_deleted=$LINES_DELETED" >> "${CACHE_FILE}.meta"
            echo "files_changed=$FILES_CHANGED" >> "${CACHE_FILE}.meta"
            echo "extended_analysis=true" >> "${CACHE_FILE}.meta"
            
            # Cleanup temp files
            rm -f lines_added.tmp lines_deleted.tmp
            
          else
            # Simple commit collection with graceful fallback
            echo "üîç Collecting commits (simple mode)..."

            # Determine git log arguments based on mode
            if [ "$USE_REF_MODE" = "true" ]; then
              GIT_LOG_RANGE="$COMMIT_RANGE"
            else
              GIT_LOG_RANGE="--since=$SINCE_DATE"
            fi

            if ! git log $GIT_LOG_RANGE $GIT_FILTERS \
              --pretty=format:'%H|%s|%an|%ad|%h' --date=short > commits.txt; then
              echo "‚ö†Ô∏è  Advanced filters failed, using basic collection"
              git log $GIT_LOG_RANGE --no-merges \
                --pretty=format:'%H|%s|%an|%ad|%h' --date=short > commits.txt || true
            fi
            echo "extended_analysis=false" >> "$GITHUB_OUTPUT"
            
            # Cache simple results
            cp commits.txt "${CACHE_FILE}_commits.txt"
            echo "extended_analysis=false" > "${CACHE_FILE}.meta"
          fi
          
          # Clean old cache files (keep last 5 cache sets)
          find "$CACHE_DIR" -name "*_commits.txt" -type f -printf '%T+ %p\n' | sort -r | tail -n +6 | cut -d' ' -f2- | sed 's/_commits\.txt$//' | xargs -I {} rm -f {}_* 2>/dev/null || true
        fi

        # Debug: Show what we found
        if [[ -f commits.txt ]]; then
          COMMIT_COUNT=$(wc -l < commits.txt 2>/dev/null || echo "0")
          echo "üìã Debug: commits.txt exists with $COMMIT_COUNT lines"
          if [[ $COMMIT_COUNT -gt 0 ]]; then
            echo "üìù Debug: First few commits:"
            head -3 commits.txt || echo "Could not read commits.txt"
          fi
        else
          echo "üìã Debug: commits.txt does not exist"
        fi
        
        if [[ ! -s commits.txt ]]; then
          if [ "$USE_REF_MODE" = "true" ]; then
            echo "‚ÑπÔ∏è No commits found in range $COMMIT_RANGE."
          else
            echo "‚ÑπÔ∏è No commits found in the past $DAYS_BACK days."
          fi
          echo "has_commits=false" >> "$GITHUB_OUTPUT"
        else
          COMMIT_COUNT=$(wc -l < commits.txt)
          echo "‚úÖ Found $COMMIT_COUNT commits"
          echo "has_commits=true" >> "$GITHUB_OUTPUT"
          echo "commit_count=$COMMIT_COUNT" >> "$GITHUB_OUTPUT"
        fi

    - name: Setup Python
      if: steps.commits.outputs.has_commits == 'true'
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install Python dependencies
      if: steps.commits.outputs.has_commits == 'true'
      shell: bash
      run: |
        python -m pip install --upgrade pip
        pip install "openai>=1.14,<2" requests

    - name: Generate changelog with OpenRouter
      if: steps.commits.outputs.has_commits == 'true'
      shell: bash
      env:
        OPENROUTER_API_KEY: ${{ inputs.openrouter_api_key }}
        MODEL: ${{ inputs.model }}
        OUTPUT_LANGUAGE: ${{ inputs.language }}
        FORCE_UPDATE: ${{ inputs.force }}
        DRY_RUN: ${{ inputs.dry_run }}
        EXTENDED_ANALYSIS: ${{ steps.commits.outputs.extended_analysis }}
        LINES_ADDED: ${{ steps.commits.outputs.lines_added }}
        LINES_DELETED: ${{ steps.commits.outputs.lines_deleted }}
        FILES_CHANGED: ${{ steps.commits.outputs.files_changed }}
        DAYS_BACK: ${{ inputs.days_back }} # Pass days_back for validation
        GITHUB_REPOSITORY: ${{ github.repository }} # Pass repository info to the script
      run: python3 ${{ github.action_path }}/src/generate_changelog.py

    - name: Get week info
      if: steps.commits.outputs.has_commits == 'true'
      id: get_week
      shell: bash
      run: |
        echo "week_num=$(date +%V)" >> "$GITHUB_OUTPUT"
        echo "year=$(date +%Y)" >> "$GITHUB_OUTPUT"

    - name: Commit and push changelog
      if: steps.commits.outputs.has_commits == 'true' && inputs.dry_run != 'true'
      uses: stefanzweifel/git-auto-commit-action@v5
      with:
        commit_message: |
          docs: update weekly changelog (week ${{ steps.get_week.outputs.week_num }}, ${{ steps.get_week.outputs.year }})${{ inputs.force == 'true' && ' - forced update' || '' }}
        file_pattern: 'CHANGELOG.md'
        commit_user_name: 'github-actions[bot]'
        commit_user_email: '41898282+github-actions[bot]@users.noreply.github.com'

    - name: Output dry-run results
      if: steps.commits.outputs.has_commits == 'true' && inputs.dry_run == 'true'
      shell: bash
      run: |
        echo "## üß™ Dry Run - Changelog Preview" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "The following changelog would be generated (not committed):" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Commits processed:** ${{ steps.commits.outputs.commit_count }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Model used:** ${{ inputs.model }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Language:** ${{ inputs.language }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Extended analysis:** ${{ inputs.extended }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo '```markdown' >> $GITHUB_STEP_SUMMARY
        head -100 CHANGELOG.md >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY

    - name: Create summary
      if: steps.commits.outputs.has_commits == 'true' && inputs.dry_run != 'true'
      shell: bash
      run: |
        echo "## üìù Weekly Changelog Generated" >> $GITHUB_STEP_SUMMARY
        echo "- **Commits processed:** ${{ steps.commits.outputs.commit_count }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Model used:** ${{ inputs.model }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Language:** ${{ inputs.language }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Extended analysis:** ${{ inputs.extended }}" >> $GITHUB_STEP_SUMMARY
        echo "Changelog has been updated! üéâ" >> $GITHUB_STEP_SUMMARY

    - name: No commits found
      if: steps.commits.outputs.has_commits == 'false'
      shell: bash
      run: |
        echo "## ‚ÑπÔ∏è No Changes Found" >> $GITHUB_STEP_SUMMARY
        if [ -n "${{ inputs.from_ref }}" ]; then
          echo "No commits found in range ${{ inputs.from_ref }}..${{ inputs.to_ref }}. Changelog was not updated." >> $GITHUB_STEP_SUMMARY
        else
          echo "No commits found in the past ${{ inputs.days_back }} days. Changelog was not updated." >> $GITHUB_STEP_SUMMARY
        fi